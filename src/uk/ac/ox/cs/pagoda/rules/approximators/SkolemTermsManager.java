package uk.ac.ox.cs.pagoda.rules.approximators;

import org.semanticweb.HermiT.model.*;
import uk.ac.ox.cs.pagoda.util.Namespace;
import uk.ac.ox.cs.pagoda.util.tuples.Tuple;

import java.util.HashMap;
import java.util.Map;

/**
 * If you need a Skolem term (i.e. fresh individual), ask this class.
 */
public class SkolemTermsManager {

    public static final String SKOLEMISED_INDIVIDUAL_PREFIX = Namespace.PAGODA_ANONY + "individual";

    private static SkolemTermsManager skolemTermsManager;

    private int termsCounter = 0;
    private Map<DLClause, Integer> mapClauseToId = new HashMap<>();
    private Map<Individual, Integer> mapTermToDepth = new HashMap<>();
    private int dependenciesCounter = 0;

    // TODO replace with hashcode. in case of collision you get only a different upper bound model.
    // TODO you can use a cash.
    private Map<Tuple<Individual>, Integer> mapDependencyToId = new HashMap<>();

    private SkolemTermsManager() {
    }

    public static int indexOfSkolemisedIndividual(Atom atom) {
        Term t;
        for(int index = 0; index < atom.getArity(); ++index) {
            t = atom.getArgument(index);
            if(t instanceof Individual && ((Individual) t).getIRI().contains(SKOLEMISED_INDIVIDUAL_PREFIX))
                return index;
        }
        return -1;
    }

    public static SkolemTermsManager getInstance() {
        if(skolemTermsManager == null) skolemTermsManager = new SkolemTermsManager();
        return skolemTermsManager;
    }

    /**
     * Get a fresh Individual, unique for the clause, the offset and the dependency.
     * */
    public Individual getFreshIndividual(DLClause originalClause, int offset, Tuple<Individual> dependency) {
        if(!mapClauseToId.containsKey(originalClause)) {
            mapClauseToId.put(originalClause, termsCounter);
            termsCounter += noOfExistential(originalClause);
        }
        if (!mapDependencyToId.containsKey(dependency)) {
            mapDependencyToId.put(dependency, dependenciesCounter++);
        }

        String termId = mapClauseToId.get(originalClause) + offset + "_" + mapDependencyToId(dependency);
        Individual newIndividual = Individual.create(SKOLEMISED_INDIVIDUAL_PREFIX + termId);

        int depth = 0;
        for (Individual individual : dependency)
            depth = Integer.max(depth, mapIndividualToDepth(individual));
        mapTermToDepth.put(newIndividual, depth);

        return newIndividual;
    }

    /**
     * Get a fresh Individual, unique for the clause and the offset.
     * */
    public Individual getFreshIndividual(DLClause originalClause, int offset) {
        if(!mapClauseToId.containsKey(originalClause)) {
            mapClauseToId.put(originalClause, termsCounter);
            termsCounter += noOfExistential(originalClause);
        }

        String termId = "" + mapClauseToId.get(originalClause) + offset;
        Individual newIndividual = Individual.create(SKOLEMISED_INDIVIDUAL_PREFIX + termId);
        mapTermToDepth.put(newIndividual, 0);

        return newIndividual;
    }

    /**
     * Get the depth of a term.
     * <p>
     * The term must have been generated by this manager.
     * */
    public int getDepthOf(Individual individual) {
        return mapIndividualToDepth(individual);
    }

    /**
     * Get the number of individuals generated by this manager.
     * */
    public int getNumberOfSkolemisedIndividual() {
        return mapTermToDepth.keySet().size();
    }

    private int mapDependencyToId(Tuple<Individual> dependency) {
        if (mapDependencyToId.containsKey(dependency)) return mapDependencyToId.get(dependency);
        else return mapDependencyToId.put(dependency, dependenciesCounter++);
    }

    private int mapIndividualToDepth(Individual dependency) {
        if(mapTermToDepth.containsKey(dependency)) return mapTermToDepth.get(dependency);
        else return 0;
    }

    private int noOfExistential(DLClause originalClause) {
        int no = 0;
        for (Atom atom : originalClause.getHeadAtoms())
            if (atom.getDLPredicate() instanceof AtLeast)
                no += ((AtLeast) atom.getDLPredicate()).getNumber();
        return no;
    }
}
