package uk.ac.ox.cs.pagoda.rules.approximators;

import org.semanticweb.HermiT.model.*;
import uk.ac.ox.cs.pagoda.util.Namespace;
import uk.ac.ox.cs.pagoda.util.tuples.Tuple;

import java.util.HashMap;
import java.util.Map;

/**
 * If you need a Skolem term (i.e. fresh individual), ask this class.
 */
public class SkolemTermsManager {

    public static final String skolemisedIndividualPrefix = Namespace.PAGODA_ANONY + "individual";

    private static SkolemTermsManager skolemTermsManager;

    private int individualCounter = 0;
    private Map<DLClause, Integer> termNumber = new HashMap<>();
    private Map<Individual, Integer> mapIndividualToDepth = new HashMap<>();
    private int dependenciesCounter = 0;

    // replace with hashcode. in case of collision you get only a different upper bound model.
    private Map<Tuple<Individual>, Integer> mapDependencyToId = new HashMap<>();

    /**
     * Get a fresh Individual, unique for the clause, the offset and the dependency.
     * */
    public Individual getFreshIndividual(DLClause originalClause, int offset, Tuple<Individual> dependency) {
        if (!termNumber.containsKey(originalClause)) {
            termNumber.put(originalClause, individualCounter);
            individualCounter += noOfExistential(originalClause);
        }
        if (!mapDependencyToId.containsKey(dependency)) {
            mapDependencyToId.put(dependency, dependenciesCounter++);
        }

        String termId = termNumber.get(originalClause) + offset + "_" + mapDependencyToId(dependency);
        Individual newIndividual = Individual.create(skolemisedIndividualPrefix + termId);

        int depth = 0;
        for (Individual individual : dependency)
            depth = Integer.max(depth, mapIndividualToDepth(individual));
        mapIndividualToDepth.put(newIndividual, depth);

        return newIndividual;
    }

    /**
     * Get a fresh Individual, unique for the clause and the offset.
     * */
    public Individual getFreshIndividual(DLClause originalClause, int offset) {
        if (!termNumber.containsKey(originalClause)) {
            termNumber.put(originalClause, individualCounter);
            individualCounter += noOfExistential(originalClause);
        }

        String termId = "" + termNumber.get(originalClause) + offset;
        Individual newIndividual = Individual.create(skolemisedIndividualPrefix + termId);
        mapIndividualToDepth.put(newIndividual, 0);

        return newIndividual;
    }

    /**
     * Get the depth of a term.
     * <p>
     * The term must have been generated by this manager.
     * */
    public int getDepth(Individual individual) {
        return mapIndividualToDepth(individual);
    }

    /**
     * Get the number of individuals generated by this manager.
     * */
    public int getNumberOfSkolemisedIndividual() {
        return mapIndividualToDepth.keySet().size();
	}

    public static int indexOfSkolemisedIndividual(Atom atom) {
        Term t;
        for (int index = 0; index < atom.getArity(); ++index) {
            t = atom.getArgument(index);
            if (t instanceof Individual && ((Individual) t).getIRI().contains(skolemisedIndividualPrefix)) return index;
        }
        return -1;
    }

    private SkolemTermsManager() {
    }

    public static SkolemTermsManager getInstance() {
        if (skolemTermsManager == null) skolemTermsManager = new SkolemTermsManager();
        return skolemTermsManager;
    }

    private int mapDependencyToId(Tuple<Individual> dependency) {
        if (mapDependencyToId.containsKey(dependency)) return mapDependencyToId.get(dependency);
        else return mapDependencyToId.put(dependency, dependenciesCounter++);
    }

    private int mapIndividualToDepth(Individual dependency) {
        if (mapIndividualToDepth.containsKey(dependency)) return mapIndividualToDepth.get(dependency);
        else return 0;
    }

    private int noOfExistential(DLClause originalClause) {
        int no = 0;
        for (Atom atom : originalClause.getHeadAtoms())
            if (atom.getDLPredicate() instanceof AtLeast)
                no += ((AtLeast) atom.getDLPredicate()).getNumber();
        return no;
    }
}
